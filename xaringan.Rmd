---
title: "Encrypting with <b>R</b>"
subtitle: "From protecting passwords to setting up a blockchain"
author: "Alejandro J Rico"
date: "27th of May, 2021"
output:
  xaringan::moon_reader:
    css: 
      - default
      - css/mytheme.css
      - css/mytheme-fonts.css
    lib_dir: libs
    seal: false
    self_contained: false
    nature:
      highlightStyle: googlecode
      highlightLines: true
      countIncrementalSlides: false
      ratio: 16:10
      #ratio: 191:100
      beforeInit: "macros.js"
      slideNumberFormat: |
        <div class="progress-bar-container">
          <div class="progress-bar" style="width: calc(%current% / %total% * 100%);">
          </div>
        </div>
---

```{r setup, include = FALSE}
options(htmltools.dir.version = FALSE)
library(knitr)
library(tidyverse)
library(icons)
library(emo)
xaringanExtra::use_panelset()
```


class: title-slide, right, top
background-image: url(img/currencsies.jpg), url(img/security.jpg)
background-position: 90% 75%, 75% 75%
background-size: 8%, cover

.right-column[
<br>
# `r rmarkdown::metadata$title`
### `r rmarkdown::metadata$subtitle`

**`r rmarkdown::metadata$author`**<br>
`r rmarkdown::metadata$date`
]

---
name: about-me
layout: false
class: about-me-slide, inverse, middle, center

# About me

  <img style="border-radius: 50%;" src="img/avatar.png" width="150px"/>

  ## Alejandro J Rico

  .fade[R Developer]
  
  .list[
    [`r shiny::icon("home")` aljrico.com](https://aljrico.com) <br>
    [`r shiny::icon("twitter")` @aljrico](https://twitter.com/aljrico) <br>
    [`r shiny::icon("github")` /aljrico](https://github.com/aljrico) <br>
  ]

---

name: outline
layout: false
class: top

# Outline

.pull-left-wide[
`r shiny::icon("qrcode")` Digesting R objects <br> <br>
`r shiny::icon("shield")` Protecting passwords <br> <br>
`r shiny::icon("comments")` Message Authentication <br> <br>
`r shiny::icon("envelope-open-text")` End-to-end encryption <br> <br>
`r shiny::icon("cubes")` What is a blockchain? <br> <br>
`r shiny::icon("cube")` Creating your first blockchain <br> <br>
]

---


name: encrypt_r_objects

# `r shiny::icon("qrcode")` Digesting R objects

.panelset[
  .panel[.panel-name[Libraries]
    Install these libraries
  ```{r, eval = FALSE, echo = TRUE}
  install.packages('digest')
  install.packages('openssl')
  ```
  ]
  .panel[.panel-name[Hashing Algorithms]
  ```{r, eval = TRUE, echo = TRUE}
  r_object <- c(4, 8, 15, 16, 23, 42)
  ```
  ```{r, eval = TRUE, echo = TRUE}
  digest::digest(r_object, algo = "md5")
  digest::digest(r_object, algo = "sha256")
  ```
  ]
  .panel[.panel-name[Digesting text]
  Small changes lead to radically different hashes
  ```{r, eval = TRUE, echo = TRUE}
  text <-  "Not Penny's boat"
  text2 <- "Not Penny's boat."
  ```
  ```{r, eval = TRUE, echo = TRUE}
  digest::digest(text, algo = "sha256")
  digest::digest(text2, algo = "sha256")
  ```
  ]
]


---


name: protecting_passwords

# `r shiny::icon("shield")` Protecting Passwords

.panelset[
  .panel[.panel-name[Saving passwords]
  `r shiny::icon('exclamation-triangle')` You should _never_ save the passwords directly.
  ```{r, eval = FALSE, echo = TRUE}
  # Please don't do this
  input$register_password %>% 
    save_password()
  ```
  `r shiny::icon('lock')` Save the generated hash instead.
  ```{r, eval = FALSE, echo = TRUE}
  # Much better
  input$register_password %>% 
    digest::digest(algo = "sha256) %>% 
    save_password()
  ```
  ]
  .panel[.panel-name[Verifying credentials]
  Digesting algorithms are deterministic &nbsp; `r shiny::icon('arrow-right')` &nbsp; Equal inputs will always yield the same hash
  
  ```{r, eval = FALSE, echo = TRUE}
  verify_credentials <- function(input_username, input_password){
    credentials <- read.csv('credentials.csv') 
    digested_input_password <- digest::digest(input_password, algo = "sha256")
    
    user_credentials <- credentials %>% 
      dplyr::filter(username == input_username) %>% 
      dplyr::filter(hashed_password == digested_input_password)
    
    if(nrow(user_credentials) > 0) return(TRUE) else return(FALSE)
  }
  
  ```
  
  We can then verify if the password a user introduces is the same they used to register. <br>
  Even if we don't know the actual password!
  ]
  .panel[.panel-name[Salting]
  `r shiny::icon('plus-square')` &nbsp; Salt is added to the hashing process to force their uniqueness
  ```{r, eval = TRUE, echo = TRUE}
  hash_password <- function(input_password, salt){
    paste0(salt, input_password) %>% digest::digest(algo = "sha256")
  }
  ```
  ```{r, eval = TRUE, echo = TRUE}
  hash_password("password1234", salt = "bagel")
  hash_password("password1234", salt = "challah")
  ```
  ]
]

---


name: message_authentication

# `r shiny::icon("comments")` Message Authentication

.panelset[
  .panel[.panel-name[MAC]
  `r shiny::icon("user-secret")` Like a common password to enter a secret club. A **M**essage **A**uthentication **C**ode (MAC) is based on a shared secret between the sender and the receiver.
  
  ```{r, eval = FALSE, echo = TRUE}
  httr::POST(
    url = "http://hydra.island/access",
    body = list(
      message = "Destroy everything",
      secret_code = "polar bear"
    )
  )
  ```
  How do I know it's you who's sending me this? Because you're the only other server who also knows this secret code.
  ]
  .panel[.panel-name[...]
  `r shiny::icon("plane-departure")` Let's say you are a member of the secret service. You are alone on an airport, waiting for your next flight. As you are pretty bored, you open your laptop and look for something to do. You spot a connection called **FREE WIFI AIRPORT**. You log in.
  
  `r shiny::icon("lightbulb")` Now let's say you decide is a great idea to send some important messages to the headquarters. You're very professional, so you'll include the `secret_code` in the message. This way the server knows it's you who sends it. Bulletproof.
  
  `r shiny::icon("door-open")` The situation is now the following: Whoever runs that WiFi might have intercepted that message. It not only has the power to read _and modify_ the message you just sent. It has the `secret_code` to keep sending messages and pretending to be you in the future. And you might never even notice it.
  ]
  .panel[.panel-name['Salted' MAC]
  `r shiny::icon("plus-square")` A safer strategy would be to use our 'Salting' technique to generate the secret code
  
  ```{r, eval = FALSE, echo = TRUE}
  message <- "Destroy everything"
  hashed_secret_code <- hash_password(message, salt = "polar bear")
  httr::POST(
    url = "http://hydra.island/access",
    body = list(
      message = message,
      secret_code = hashed_secret_code
    )
  )
  ```
  ]
  .panel[.panel-name[...]
  `r shiny::icon("thumbs-up")` Now if this is intercepted, only this message will be compromised. Since the `hashed_secret_code` will be different for each message we send. 
  
  `r shiny::icon("shield")` Knowing the message and the `hashed_secret_code` does not get anyone closer to figuring out the `secret_code.
  
  `r shiny::icon("not-equal")` If a third party intercepts and modify the message, the server will know. Because the `hashed_secret_code` will not match.
  ]
  .panel[.panel-name[HMAC]
  While salting already accomplishes what we wanted. There are still some vulnerabilities that could be exploited through what is called [length extension attack](https://en.wikipedia.org/wiki/Length_extension_attack). There are well-established functions that concatenate the 'salt' in a more convoluted manner, protecting it from those attacks.
  
  ```{r, eval = FALSE, echo = TRUE}
  digest::hmac(object = c(4, 8, 15, 16, 23, 42), key = "polar bear", algo = "sha256")
  ```
  - A HMAC uses a secret key, where as a 'salt' can be public. Though conceptually they're the same.
  - "Salting" simply concatenates a 'salt' before hashing. The HMAC process adds the key in a more complicated way.
  - Adding a `HMAC` is the current standard protocol to authenticate messages.
  ]
]

---


name: message_encryption

# `r shiny::icon("envelope-open-text")` End-to-end encryption

.panelset[
  .panel[.panel-name[Reversible algorithms]
  `r shiny::icon("blender")` So far, the algorithms we've used completely destroy all information. They are designed so it's impossible to recover the original message, based on the hash they produce. There's no backtrack method. It's non reversible.
  
  `r shiny::icon("box")` Other algorithms don't completely destroy the information. They just hide it. These algorithms have methods both to encrypt and decrypt messages. So information is not lost.
  
  <br>
  
  .center[<img src="img/reversible-encryption.png" style="max-width: 40%;"/>]
  
  ]
  .panel[.panel-name[Centralised encryption]
  `r shiny::icon("key")` We can encrypt messages using a secret key. Thus, the message can only be decrypted with the key.
  
  ```{r, eval = TRUE, echo = TRUE}
  key <- openssl::sha256(charToRaw("4815162342")); 
  msg <- digest::makeRaw("Not Penny's boat!")

  encrypted_message <- openssl::aes_cbc_encrypt(msg, key)
  rawToChar(encrypted_message)
  
  decrypted_message <- openssl::aes_cbc_decrypt(encrypted_message, key)
  rawToChar(decrypted_message)
  
  ```
  ]
]