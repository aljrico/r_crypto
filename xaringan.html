<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Encrypting with R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Alejandro J Rico" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <link href="libs/font-awesome/css/all.min.css" rel="stylesheet" />
    <link href="libs/font-awesome/css/v4-shims.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="css/mytheme.css" type="text/css" />
    <link rel="stylesheet" href="css/mytheme-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">





class: title-slide, right, top
background-image: url(img/currencsies.jpg), url(img/security.jpg)
background-position: 90% 75%, 75% 75%
background-size: 8%, cover

.right-column[
&lt;br&gt;
# Encrypting with &lt;b&gt;R&lt;/b&gt;
### From protecting passwords to setting up a blockchain

**Alejandro J Rico**&lt;br&gt;
27th of May, 2021
]

---
name: about-me
layout: false
class: about-me-slide, inverse, middle, center

# About me

  &lt;img style="border-radius: 50%;" src="img/avatar.png" width="150px"/&gt;

  ## Alejandro J Rico

  .fade[R Developer]
  
  .list[
    [<i class="fa fa-home" role="presentation" aria-label="home icon"></i> aljrico.com](https://aljrico.com) &lt;br&gt;
    [<i class="fab fa-twitter" role="presentation" aria-label="twitter icon"></i> @aljrico](https://twitter.com/aljrico) &lt;br&gt;
    [<i class="fab fa-github" role="presentation" aria-label="github icon"></i> /aljrico](https://github.com/aljrico) &lt;br&gt;
  ]

---

name: outline
layout: false
class: top

# Outline

.pull-left-wide[
#####<i class="fa fa-qrcode" role="presentation" aria-label="qrcode icon"></i> Digesting R objects
#####<i class="fa fa-shield" role="presentation" aria-label="shield icon"></i> Protecting passwords
#####<i class="fa fa-comments" role="presentation" aria-label="comments icon"></i> Message Authentication
#####<i class="fa fa-envelope-open-text" role="presentation" aria-label="envelope-open-text icon"></i> End-to-end encryption
#####<i class="fa fa-cubes" role="presentation" aria-label="cubes icon"></i> Creating your first blockchain
]

---


name: encrypt_r_objects

# <i class="fa fa-qrcode" role="presentation" aria-label="qrcode icon"></i> Digesting R objects

.panelset[
  .panel[.panel-name[Libraries]
    Install these libraries
  
  ```r
  install.packages('digest')
  install.packages('openssl')
  ```
  ]
  .panel[.panel-name[Hashing Algorithms]
  
  ```r
  r_object &lt;- c(4, 8, 15, 16, 23, 42)
  ```
  
  ```r
  digest::digest(r_object, algo = "md5")
  ```
  
  ```
  ## [1] "7238a618715488d3839d9e4b507b3d32"
  ```
  
  ```r
  digest::digest(r_object, algo = "sha256")
  ```
  
  ```
  ## [1] "0c91b468b07e8701fb0c342398b509e9ad3ee7f468b08449592540d6f7ee0b80"
  ```
  ]
  .panel[.panel-name[Digesting text]
  Small changes lead to radically different hashes
  
  ```r
  text &lt;-  "Not Penny's boat"
  text2 &lt;- "Not Penny's boat."
  ```
  
  ```r
  digest::digest(text, algo = "sha256")
  ```
  
  ```
  ## [1] "58b529f7756d833c7f9354b3c824a967cc102b93b85fa9c377fd22beb870e620"
  ```
  
  ```r
  digest::digest(text2, algo = "sha256")
  ```
  
  ```
  ## [1] "d832eb961c2e2696084dbdd6fa17e9c1e74703fe7a0a63c11a272470bcd8e4a8"
  ```
  ]
]


---


name: protecting_passwords

# <i class="fa fa-shield" role="presentation" aria-label="shield icon"></i> Protecting Passwords

.panelset[
  .panel[.panel-name[Saving passwords]
  <i class="fa fa-exclamation-triangle" role="presentation" aria-label="exclamation-triangle icon"></i> You should _never_ save the passwords directly.
  
  ```r
  # Please don't do this
  input$register_password %&gt;% 
    save_password()
  ```
  <i class="fa fa-lock" role="presentation" aria-label="lock icon"></i> Save the generated hash instead.
  
  ```r
  # Much better
  input$register_password %&gt;% 
    digest::digest(algo = "sha256) %&gt;% 
    save_password()
  ```
  ]
  .panel[.panel-name[Verifying credentials]
  Digesting algorithms are deterministic &amp;nbsp; <i class="fa fa-arrow-right" role="presentation" aria-label="arrow-right icon"></i> &amp;nbsp; Equal inputs will always yield the same hash
  
  
  ```r
  verify_credentials &lt;- function(input_username, input_password){
    credentials &lt;- read.csv('credentials.csv') 
    digested_input_password &lt;- digest::digest(input_password, algo = "sha256")
    
    user_credentials &lt;- credentials %&gt;% 
      dplyr::filter(username == input_username) %&gt;% 
      dplyr::filter(hashed_password == digested_input_password)
    
    if(nrow(user_credentials) &gt; 0) return(TRUE) else return(FALSE)
  }
  ```
  
  We can then verify if the password a user introduces is the same they used to register. &lt;br&gt;
  Even if we don't know the actual password!
  ]
  .panel[.panel-name[Salting]
  <i class="fa fa-plus-square" role="presentation" aria-label="plus-square icon"></i> &amp;nbsp; Salt is added to the hashing process to force their uniqueness
  
  ```r
  hash_password &lt;- function(input_password, salt){
    paste0(salt, input_password) %&gt;% digest::digest(algo = "sha256")
  }
  ```
  
  ```r
  hash_password("password1234", salt = "bagel")
  ```
  
  ```
  ## [1] "7cf0997df40c7a5f8aeb3de319712acb93657534e4cd4c70424249ad5934aa71"
  ```
  
  ```r
  hash_password("password1234", salt = "challah")
  ```
  
  ```
  ## [1] "e4472c6495f006b9281a226b1af7ca0eca0f8c51efe7b8e61238fe1e5fb00520"
  ```
  ]
]

---


name: message_authentication

# <i class="fa fa-comments" role="presentation" aria-label="comments icon"></i> Message Authentication

.panelset[
  .panel[.panel-name[MAC]
  <i class="fa fa-user-secret" role="presentation" aria-label="user-secret icon"></i> Like a common password to enter a secret club. A **M**essage **A**uthentication **C**ode (MAC) is based on a shared secret between the sender and the receiver.
  
  
  ```r
  httr::POST(
    url = "http://hydra.island/access",
    body = list(
      message = "Execute order 66",
      secret_code = "polar bear"
    )
  )
  ```
  How do I know it's you who's sending me this? Because you're the only other server who also knows this secret code.
  ]
  .panel[.panel-name[...]
  <i class="fa fa-plane-departure" role="presentation" aria-label="plane-departure icon"></i> Let's say you are a member of the secret service. You are alone on an airport, waiting for your next flight. As you are pretty bored, you open your laptop and look for something to do. You spot a connection called **FREE WIFI AIRPORT**. You log in.
  
  <i class="fa fa-lightbulb" role="presentation" aria-label="lightbulb icon"></i> Now let's say you decide is a great idea to send some important messages to the headquarters. You're very professional, so you'll include the `secret_code` in the message. This way the server knows it's you who sends it. Bulletproof.
  
  <i class="fa fa-door-open" role="presentation" aria-label="door-open icon"></i> The situation is now the following: Whoever runs that WiFi might have intercepted that message. It not only has the power to read _and modify_ the message you just sent. It has the `secret_code` to keep sending messages and pretending to be you in the future. And you might never even notice it.
  ]
  .panel[.panel-name['Salted' MAC]
  <i class="fa fa-plus-square" role="presentation" aria-label="plus-square icon"></i> A safer strategy would be to use our 'Salting' technique to generate the secret code
  
  
  ```r
  message &lt;- "Execute order 66"
  hashed_secret_code &lt;- hash_password(message, salt = "polar bear")
  httr::POST(
    url = "http://hydra.island/access",
    body = list(
      message = message,
      secret_code = hashed_secret_code
    )
  )
  ```
  ]
  .panel[.panel-name[...]
  <i class="fa fa-thumbs-up" role="presentation" aria-label="thumbs-up icon"></i> Now if this is intercepted, only this message will be compromised. Since the `hashed_secret_code` will be different for each message we send. 
  
  <i class="fa fa-shield" role="presentation" aria-label="shield icon"></i> Knowing the message and the `hashed_secret_code` does not get anyone closer to figuring out the `secret_code.
  
  <i class="fa fa-not-equal" role="presentation" aria-label="not-equal icon"></i> If a third party intercepts and modify the message, the server will know. Because the `hashed_secret_code` will not match.
  ]
  .panel[.panel-name[HMAC]
  While salting already accomplishes what we wanted. There are still some vulnerabilities that could be exploited through what is called [length extension attack](https://en.wikipedia.org/wiki/Length_extension_attack). There are well-established functions that concatenate the 'salt' in a more convoluted manner, protecting it from those attacks.
  
  
  ```r
  digest::hmac(object = c(4, 8, 15, 16, 23, 42), key = "polar bear", algo = "sha256")
  ```
  - A HMAC uses a secret key, where as a 'salt' can be public. Though conceptually they're the same.
  - "Salting" simply concatenates a 'salt' before hashing. The HMAC process adds the key in a more complicated way.
  - Adding a `HMAC` is the current standard protocol to authenticate messages.
  ]
  .panel[.panel-name[...]
    
  <i class="fa fa-warning" role="presentation" aria-label="warning icon"></i> With the current configuration, a malicious 3rd party could not forge new messages. But it definitely could duplicate existing ones, if they manage to intercept them.
  
  <i class="fa fa-fingerprint" role="presentation" aria-label="fingerprint icon"></i> To prevent the forge of duplicates, it's recommended to add a unique identifier for every message sent. We then can create a `HMAC` from the entire message
  
  
  ```r
  message &lt;- list(action = "Execture order 66", id = runif(max = 10^6, n = 1))
  
  message$hmac &lt;- message %&gt;% 
    jsonlite::toJSON() %&gt;% 
    as.character() %&gt;% 
    digest::hmac(key = "polar bear", algo = "sha256")
  ```
  ]
]

---


name: message_encryption

# <i class="fa fa-envelope-open-text" role="presentation" aria-label="envelope-open-text icon"></i> End-to-end encryption

.panelset[
  .panel[.panel-name[...]
  <i class="fa fa-blender" role="presentation" aria-label="blender icon"></i> So far, the algorithms we've used completely destroy all information. They are designed so it's impossible to recover the original message, based on the hash they produce. There's no backtrack method. It's non reversible.
  
  <i class="fa fa-box" role="presentation" aria-label="box icon"></i> Other algorithms don't completely destroy the information. They just hide it. These algorithms have methods both to encrypt and decrypt messages.
  
  &lt;br&gt;
  
  .center[&lt;img src="img/reversible-encryption.png" style="max-width: 40%;"/&gt;]
  
  .center[**Encryption** is reversible, **digestion** is not]
  
]
  .panel[.panel-name[Naive encryption]
  <i class="fa fa-universal-access" role="presentation" aria-label="universal-access icon"></i> The simplest way we could do something like this is to encode our message

  
  ```r
  encoded_message &lt;- RCurl::base64Encode("Not Penny's boat!") %&gt;% as.character()
  encoded_message
  ```
  
  ```
  ## [1] "Tm90IFBlbm55J3MgYm9hdCE="
  ```
  
  ```r
  decoded_message &lt;- RCurl::base64Decode(encoded_message)
  decoded_message
  ```
  
  ```
  ## [1] "Not Penny's boat!"
  ```
  
  But that's not very safe. Anyone can decode a message hidden like this.
]
.panel[.panel-name[Key-based encryption]
  <i class="fa fa-key" role="presentation" aria-label="key icon"></i> We can cover information by protecting the encoding under a secret key. This way, the message can *only* be decrypted with the key.
  
  
  ```r
  key &lt;- openssl::sha256(charToRaw("4815162342"))
  msg &lt;- digest::makeRaw("Not Penny's boat!")
  
  encrypted_message &lt;- openssl::aes_cbc_encrypt(msg, key)
  rawToChar(encrypted_message[!encrypted_message=='00']) %&gt;% RCurl::base64Encode() %&gt;% as.character()
  ```
  
  ```
  ## [1] "+xnY/+8+XzvfbREQQG4wzZFH97NszXyif2yl/FW7qJg="
  ```
  
  ```r
  encrypted_message %&gt;% openssl::aes_cbc_decrypt(key) %&gt;% rawToChar()
  ```
  
  ```
  ## [1] "Not Penny's boat!"
  ```
  ]
  
.panel[.panel-name[Asymmetric cryptography]
  <i class="fa fa-project-diagram" role="presentation" aria-label="project-diagram icon"></i> The previous approach, while technically safe in 1-to-1 communication, has the complication of relying on a single key to identify all users. If we had to create a somewhat complex network of communications, we'd need to create a new key for every possible interaction between users. Which is unfeasible, since it grows as `2^n`. 
  
  <i class="fa fa-key" role="presentation" aria-label="key icon"></i> A more scalable solution for this comes from the [RSA](https://w.wiki/tjT) protocol that involves a pair of keys. This protocol establishes that every user will have two keys, one that can be shared (public key) and another one that should be kept safe (secret key). A powerful application of this protocol, is the development of encryption algorithms that use the **public key** to encrypt a message, but it requires the **private key** to decrypt it. 
  ]
.panel[.panel-name[...]
  
  ```r
  key &lt;- openssl::rsa_keygen()
  msg &lt;- digest::makeRaw("Not Penny's boat!")
  
  encrypted_message &lt;- openssl::rsa_encrypt(msg, key$pubkey)
  rawToChar(encrypted_message[!encrypted_message=='00']) %&gt;% RCurl::base64Encode() %&gt;% as.character()
  ```
  
  ```
  ## [1] "Plx7Pp+S+q+v2nn4NLM/J/neZiVoC7hZ6QSdjMzlps2uhdxEXiPM5xqokjnvi7ZGmm3RZkbqA9La3xgez6h5A1ufLXSXo825kXrq2ozsmVIzhp9jSTw8movjvrxpZ1Azy4zWPxFW6X0YenFLm038auKcHy5YLfpRpXfg6e6eP54ELw7LUBmc26ZD4DTNtFBq/qlXxPqXySmFRLbqKILQy9X4BZWgrsZz0tuA2QinYNjqv2xKHFshnss7vIixS5NU0jQbL2D3FanKMS9nR6KgEXwJmH0p+boa3QQaWZ5iVLDXwlRfgGXypEyArufnkW+plOb6yiqLGD1nU/JT/oNd9Q=="
  ```
  
  ```r
  decrypted_message &lt;- openssl::rsa_decrypt(encrypted_message, key)
  rawToChar(decrypted_message)
  ```
  
  ```
  ## [1] "Not Penny's boat!"
  ```
  ]
.panel[.panel-name[...]
  <i class="fa fa-exchange-alt" role="presentation" aria-label="exchange-alt icon"></i> When two users start communication, they exchange public keys. Then they use each other's public keys to encrypt the messages.
  
  <i class="fa fa-user-lock" role="presentation" aria-label="user-lock icon"></i> Let's say user *Alice* wants to send a message to user *Bob*. Alice will use Bob's public key to encrypt the message, and send it encrypted. That way, even if message is intercepted and Bob's public key is intercepted, the message will remain hidden. Since the only way to decrypt it is through Bob's secret key. 
  
  <i class="fa fa-hdd" role="presentation" aria-label="hdd icon"></i> So where are these 'secret' keys stored? Here's when the controversy kicks in. If you want to call it *end-to-end encryption*, then the secret key should only be stored in a user's client. That is the only way no third party (including the service provider) can read the messages.
  ]
]


---


name: blockchain

# <i class="fa fa-cubes" role="presentation" aria-label="cubes icon"></i> Creating your first blockchain 

.panelset[
  .panel[.panel-name[-]
   &lt;blockquote&gt; 
    A blockchain is a public database where new data are stored in a container called a block and are added to an immutable chain.    &lt;/blockquote&gt;
  
  &lt;hr&gt;
  
  <i class="fa fa-box-open" role="presentation" aria-label="box-open icon"></i> Anyone can add entries to this database
  
  <i class="fa fa-file-contract" role="presentation" aria-label="file-contract icon"></i> Every new entry is signed by its author
  
  <i class="fa fa-wrench" role="presentation" aria-label="wrench icon"></i> Every new entry needs a proof of work
  
  <i class="fa fa-hand-point-right" role="presentation" aria-label="hand-point-right icon"></i> We'll now showcase - step by step - a simplified implementation of the most common rules to define a blockchain.
  ]
  .panel[.panel-name[Blocks]
  <i class="fa fa-cube" role="presentation" aria-label="cube icon"></i> Data is organised in small containers called blocks
  
  
  ```r
  block &lt;- list(
    index = 1, 
    timestamp = Sys.time(), 
    message = "And now it begins"
  )
  ```
  
  <i class="fa fa-cubes" role="presentation" aria-label="cubes icon"></i> We can orderly stack this cubes in a `data.frame` structure
  
  ```
  ##   index           timestamp                                 message
  ## 1     1 2021-05-20 17:16:31                       And now it begins
  ## 2     2 2021-05-20 17:16:31 Woe to the Usurper if we had been there
  ## 3     3 2021-05-20 17:16:31                      Dance with me then
  ```
  ]
]

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "googlecode",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:10",
"slideNumberFormat": "<div class=\"progress-bar-container\">\n  <div class=\"progress-bar\" style=\"width: calc(%current% / %total% * 100%);\">\n  </div>\n</div>"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
