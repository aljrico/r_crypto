---
title: "Encrypting with <b>R</b>"
subtitle: "From protecting passwords to setting up a blockchain"
author: "Alejandro J Rico"
date: "27th of May, 2021"
output:
  xaringan::moon_reader:
    css: 
      - default
      - css/mytheme.css
      - css/mytheme-fonts.css
    lib_dir: libs
    seal: false
    self_contained: false
    nature:
      highlightStyle: googlecode
      highlightLines: true
      countIncrementalSlides: false
      ratio: 16:10
      #ratio: 191:100
      beforeInit: "macros.js"
      slideNumberFormat: |
        <div class="progress-bar-container">
          <div class="progress-bar" style="width: calc(%current% / %total% * 100%);">
          </div>
        </div>
---

```{r setup, include = FALSE}
options(htmltools.dir.version = FALSE)
library(knitr)
library(tidyverse)
library(icons)
library(emo)
xaringanExtra::use_panelset()
```


class: title-slide, right, top
background-image: url(img/currencsies.jpg), url(img/security.jpg)
background-position: 90% 75%, 75% 75%
background-size: 8%, cover

.right-column[
<br>
# `r rmarkdown::metadata$title`
### `r rmarkdown::metadata$subtitle`

**`r rmarkdown::metadata$author`**<br>
`r rmarkdown::metadata$date`
]

---
name: about-me
layout: false
class: about-me-slide, inverse, middle, center

# About me

  <img style="border-radius: 50%;" src="img/avatar.png" width="150px"/>

  ## Alejandro J Rico

  .fade[R Developer]
  
  .list[
    [`r shiny::icon("home")` aljrico.com](https://aljrico.com) <br>
    [`r shiny::icon("twitter")` @aljrico](https://twitter.com/aljrico) <br>
    [`r shiny::icon("github")` /aljrico](https://github.com/aljrico) <br>
  ]

---

name: outline
layout: false
class: top

# Outline

.pull-left-wide[
#####`r shiny::icon("qrcode")` Digesting R objects
#####`r shiny::icon("shield")` Protecting passwords
#####`r shiny::icon("comments")` Message Authentication
#####`r shiny::icon("envelope-open-text")` End-to-end encryption
#####`r shiny::icon("cubes")` Creating your first blockchain
]

---


name: encrypt_r_objects

# `r shiny::icon("qrcode")` Digesting R objects

.panelset[
  .panel[.panel-name[Libraries]
    Install these libraries
  ```{r, eval = FALSE, echo = TRUE}
  install.packages('digest')
  install.packages('openssl')
  ```
  ]
  .panel[.panel-name[Hashing Algorithms]
  ```{r, eval = TRUE, echo = TRUE}
  r_object <- c(4, 8, 15, 16, 23, 42)
  ```
  ```{r, eval = TRUE, echo = TRUE}
  digest::digest(r_object, algo = "md5")
  digest::digest(r_object, algo = "sha256")
  ```
  ]
  .panel[.panel-name[Digesting text]
  Small changes lead to radically different hashes
  ```{r, eval = TRUE, echo = TRUE}
  text <-  "Not Penny's boat"
  text2 <- "Not Penny's boat."
  ```
  ```{r, eval = TRUE, echo = TRUE}
  digest::digest(text, algo = "sha256")
  digest::digest(text2, algo = "sha256")
  ```
  ]
]


---


name: protecting_passwords

# `r shiny::icon("shield")` Protecting Passwords

.panelset[
  .panel[.panel-name[Saving passwords]
  `r shiny::icon('exclamation-triangle')` You should _never_ save the passwords directly.
  ```{r, eval = FALSE, echo = TRUE}
  # Please don't do this
  input$register_password %>% 
    save_password()
  ```
  `r shiny::icon('lock')` Save the generated hash instead.
  ```{r, eval = FALSE, echo = TRUE}
  # Much better
  input$register_password %>% 
    digest::digest(algo = "sha256) %>% 
    save_password()
  ```
  ]
  .panel[.panel-name[Verifying credentials]
  Digesting algorithms are deterministic &nbsp; `r shiny::icon('arrow-right')` &nbsp; Equal inputs will always yield the same hash
  
  ```{r, eval = FALSE, echo = TRUE}
  verify_credentials <- function(input_username, input_password){
    credentials <- read.csv('credentials.csv') 
    digested_input_password <- digest::digest(input_password, algo = "sha256")
    
    user_credentials <- credentials %>% 
      dplyr::filter(username == input_username) %>% 
      dplyr::filter(hashed_password == digested_input_password)
    
    if(nrow(user_credentials) > 0) return(TRUE) else return(FALSE)
  }
  
  ```
  
  We can then verify if the password a user introduces is the same they used to register. <br>
  Even if we don't know the actual password!
  ]
  .panel[.panel-name[Salting]
  `r shiny::icon('plus-square')` &nbsp; Salt is added to the hashing process to force their uniqueness
  ```{r, eval = TRUE, echo = TRUE}
  hash_password <- function(input_password, salt){
    paste0(salt, input_password) %>% digest::digest(algo = "sha256")
  }
  ```
  ```{r, eval = TRUE, echo = TRUE}
  hash_password("password1234", salt = "bagel")
  hash_password("password1234", salt = "challah")
  ```
  ]
]

---


name: message_authentication

# `r shiny::icon("comments")` Message Authentication

.panelset[
  .panel[.panel-name[MAC]
  `r shiny::icon("user-secret")` Like a common password to enter a secret club. A **M**essage **A**uthentication **C**ode (MAC) is based on a shared secret between the sender and the receiver.
  
  ```{r, eval = FALSE, echo = TRUE}
  httr::POST(
    url = "http://hydra.island/access",
    body = list(
      message = "Execute order 66",
      secret_code = "polar bear"
    )
  )
  ```
  How do I know it's you who's sending me this? Because you're the only other server who also knows this secret code.
  ]
  .panel[.panel-name[...]
  `r shiny::icon("plane-departure")` Let's say you are a member of the secret service. You are alone on an airport, waiting for your next flight. As you are pretty bored, you open your laptop and look for something to do. You spot a connection called **FREE WIFI AIRPORT**. You log in.
  
  `r shiny::icon("lightbulb")` Now let's say you decide is a great idea to send some important messages to the headquarters. You're very professional, so you'll include the `secret_code` in the message. This way the server knows it's you who sends it. Bulletproof.
  
  `r shiny::icon("door-open")` The situation is now the following: Whoever runs that WiFi might have intercepted that message. It not only has the power to read _and modify_ the message you just sent. It has the `secret_code` to keep sending messages and pretending to be you in the future. And you might never even notice it.
  ]
  .panel[.panel-name['Salted' MAC]
  `r shiny::icon("plus-square")` A safer strategy would be to use our 'Salting' technique to generate the secret code
  
  ```{r, eval = FALSE, echo = TRUE}
  message <- "Execute order 66"
  hashed_secret_code <- hash_password(message, salt = "polar bear")
  httr::POST(
    url = "http://hydra.island/access",
    body = list(
      message = message,
      secret_code = hashed_secret_code
    )
  )
  ```
  ]
  .panel[.panel-name[...]
  `r shiny::icon("thumbs-up")` Now if this is intercepted, only this message will be compromised. Since the `hashed_secret_code` will be different for each message we send. 
  
  `r shiny::icon("shield")` Knowing the message and the `hashed_secret_code` does not get anyone closer to figuring out the `secret_code.
  
  `r shiny::icon("not-equal")` If a third party intercepts and modify the message, the server will know. Because the `hashed_secret_code` will not match.
  ]
  .panel[.panel-name[HMAC]
  While salting already accomplishes what we wanted. There are still some vulnerabilities that could be exploited through what is called [length extension attack](https://en.wikipedia.org/wiki/Length_extension_attack). There are well-established functions that concatenate the 'salt' in a more convoluted manner, protecting it from those attacks.
  
  ```{r, eval = FALSE, echo = TRUE}
  digest::hmac(object = c(4, 8, 15, 16, 23, 42), key = "polar bear", algo = "sha256")
  ```
  - A HMAC uses a secret key, where as a 'salt' can be public. Though conceptually they're the same.
  - "Salting" simply concatenates a 'salt' before hashing. The HMAC process adds the key in a more complicated way.
  - Adding a `HMAC` is the current standard protocol to authenticate messages.
  ]
  .panel[.panel-name[...]
    
  `r shiny::icon("warning")` With the current configuration, a malicious 3rd party could not forge new messages. But it definitely could duplicate existing ones, if they manage to intercept them.
  
  `r shiny::icon("fingerprint")` To prevent the forge of duplicates, it's recommended to add a unique identifier for every message sent. We then can create a `HMAC` from the entire message
  
  ```{r, eval = TRUE, echo = TRUE}
  message <- list(action = "Execture order 66", id = runif(max = 10^6, n = 1))
  
  message$hmac <- message %>% 
    jsonlite::toJSON() %>% 
    as.character() %>% 
    digest::hmac(key = "polar bear", algo = "sha256")
  ```
  ]
]

---


name: message_encryption

# `r shiny::icon("envelope-open-text")` End-to-end encryption

.panelset[
  .panel[.panel-name[...]
  `r shiny::icon("blender")` So far, the algorithms we've used completely destroy all information. They are designed so it's impossible to recover the original message, based on the hash they produce. There's no backtrack method. It's non reversible.
  
  `r shiny::icon("box")` Other algorithms don't completely destroy the information. They just hide it. These algorithms have methods both to encrypt and decrypt messages.
  
  <br>
  
  .center[<img src="img/reversible-encryption.png" style="max-width: 40%;"/>]
  
  .center[**Encryption** is reversible, **digestion** is not]
  
]
  .panel[.panel-name[Naive encryption]
  `r shiny::icon("universal-access")` The simplest way we could do something like this is to encode our message

  ```{r, eval = TRUE, echo = TRUE}
  encoded_message <- RCurl::base64Encode("Not Penny's boat!") %>% as.character()
  encoded_message
  
  decoded_message <- RCurl::base64Decode(encoded_message)
  decoded_message
  ```
  
  But that's not very safe. Anyone can decode a message hidden like this.
]
.panel[.panel-name[Key-based encryption]
  `r shiny::icon("key")` We can cover information by protecting the encoding under a secret key. This way, the message can *only* be decrypted with the key.
  
  ```{r, eval = TRUE, echo = TRUE}
  key <- openssl::sha256(charToRaw("4815162342"))
  msg <- digest::makeRaw("Not Penny's boat!")

  encrypted_message <- openssl::aes_cbc_encrypt(msg, key)
  rawToChar(encrypted_message[!encrypted_message=='00']) %>% RCurl::base64Encode() %>% as.character()
  
  encrypted_message %>% openssl::aes_cbc_decrypt(key) %>% rawToChar()
  ```
  ]
  
.panel[.panel-name[Asymmetric cryptography]
  `r shiny::icon("project-diagram")` The previous approach, while technically safe in 1-to-1 communication, has the complication of relying on a single key to identify all users. If we had to create a somewhat complex network of communications, we'd need to create a new key for every possible interaction between users. Which is unfeasible, since it grows as `2^n`. 
  
  `r shiny::icon("key")` A more scalable solution for this comes from the [RSA](https://w.wiki/tjT) protocol that involves a pair of keys. This protocol establishes that every user will have two keys, one that can be shared (public key) and another one that should be kept safe (secret key). A powerful application of this protocol, is the development of encryption algorithms that use the **public key** to encrypt a message, but it requires the **private key** to decrypt it. 
  ]
.panel[.panel-name[...]
  ```{r, eval = TRUE, echo = TRUE}
  key <- openssl::rsa_keygen()
  msg <- digest::makeRaw("Not Penny's boat!")
  
  encrypted_message <- openssl::rsa_encrypt(msg, key$pubkey)
  rawToChar(encrypted_message[!encrypted_message=='00']) %>% RCurl::base64Encode() %>% as.character()
  
  decrypted_message <- openssl::rsa_decrypt(encrypted_message, key)
  rawToChar(decrypted_message)
  ```
  ]
.panel[.panel-name[...]
  `r shiny::icon("exchange-alt")` When two users start communication, they exchange public keys. Then they use each other's public keys to encrypt the messages.
  
  `r shiny::icon("user-lock")` Let's say user *Alice* wants to send a message to user *Bob*. Alice will use Bob's public key to encrypt the message, and send it encrypted. That way, even if message is intercepted and Bob's public key is intercepted, the message will remain hidden. Since the only way to decrypt it is through Bob's secret key. 
  
  `r shiny::icon("hdd")` So where are these 'secret' keys stored? Here's when the controversy kicks in. If you want to call it *end-to-end encryption*, then the secret key should only be stored in a user's client. That is the only way no third party (including the service provider) can read the messages.
  ]
]


---


name: blockchain

# `r shiny::icon("cubes")` Creating your first blockchain 

.panelset[
  .panel[.panel-name[-]
   <blockquote> 
    A blockchain is a public database where new data are stored in a container called a block and are added to an immutable chain.    </blockquote>
  
  <hr>
  
  `r shiny::icon("box-open")` Anyone can add entries to this database
  
  `r shiny::icon("file-contract")` Every new entry is signed by its author
  
  `r shiny::icon("wrench")` Every new entry needs a proof of work
  
  `r shiny::icon("hand-point-right")` We'll now showcase - step by step - a simplified implementation of the most common rules to define a blockchain.
  ]
  .panel[.panel-name[Blocks]
  `r shiny::icon("cube")` Data is organised in small containers called blocks
  
  ```{r, eval = TRUE, echo = TRUE}
  block <- list(
    index = 1, 
    timestamp = Sys.time(), 
    message = "And now it begins"
  )
  ```
  
  `r shiny::icon("cubes")` We can orderly stack this cubes in a `data.frame` structure
  ```{r, eval = TRUE, echo = FALSE}
    block1 <- list(
    index = 1, 
    timestamp = Sys.time(), 
    message = "And now it begins"
    )
    block2 <- list(
    index = 2, 
    timestamp = Sys.time(), 
    message = "Woe to the Usurper if we had been there"
    )
    
    block3 <- list(
    index = 3, 
    timestamp = Sys.time(), 
    message = "Dance with me then"
    )
    
    blockchain <- rbind(data.frame(block1), data.frame(block2), data.frame(block3))
    
    blockchain
  ```
  ]
]

