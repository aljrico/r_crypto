<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Encrypting with R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Alejandro J Rico" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <link href="libs/font-awesome/css/all.min.css" rel="stylesheet" />
    <link href="libs/font-awesome/css/v4-shims.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="css/mytheme.css" type="text/css" />
    <link rel="stylesheet" href="css/mytheme-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">





class: title-slide, right, top
background-image: url(img/currencsies.jpg), url(img/security.jpg)
background-position: 90% 75%, 75% 75%
background-size: 8%, cover

.right-column[
&lt;br&gt;
# Encrypting with &lt;b&gt;R&lt;/b&gt;
### From protecting passwords to setting up a blockchain

**Alejandro J Rico**&lt;br&gt;
27th of May, 2021
]

---
name: about-me
layout: false
class: about-me-slide, inverse, middle, center

# About me

  &lt;img style="border-radius: 50%;" src="img/avatar.png" width="150px"/&gt;

  ## Alejandro J Rico

  .fade[R Developer]
  
  .list[
    [<i class="fa fa-home" role="presentation" aria-label="home icon"></i> aljrico.com](https://aljrico.com) &lt;br&gt;
    [<i class="fab fa-twitter" role="presentation" aria-label="twitter icon"></i> @aljrico](https://twitter.com/aljrico) &lt;br&gt;
    [<i class="fab fa-github" role="presentation" aria-label="github icon"></i> /aljrico](https://github.com/aljrico) &lt;br&gt;
  ]

---

name: outline
layout: false
class: top

# Outline

.pull-left-wide[
<i class="fa fa-qrcode" role="presentation" aria-label="qrcode icon"></i> Digesting R objects &lt;br&gt; &lt;br&gt;
<i class="fa fa-shield" role="presentation" aria-label="shield icon"></i> Protecting passwords &lt;br&gt; &lt;br&gt;
<i class="fa fa-comments" role="presentation" aria-label="comments icon"></i> Message Authentication &lt;br&gt; &lt;br&gt;
<i class="fa fa-envelope-open-text" role="presentation" aria-label="envelope-open-text icon"></i> End-to-end encryption &lt;br&gt; &lt;br&gt;
<i class="fa fa-cubes" role="presentation" aria-label="cubes icon"></i> What is a blockchain? &lt;br&gt; &lt;br&gt;
<i class="fa fa-cube" role="presentation" aria-label="cube icon"></i> Creating your first blockchain &lt;br&gt; &lt;br&gt;
]

---


name: encrypt_r_objects

# <i class="fa fa-qrcode" role="presentation" aria-label="qrcode icon"></i> Digesting R objects

.panelset[
  .panel[.panel-name[Libraries]
    Install these libraries
  
  ```r
  install.packages('digest')
  install.packages('openssl')
  ```
  ]
  .panel[.panel-name[Hashing Algorithms]
  
  ```r
  r_object &lt;- c(4, 8, 15, 16, 23, 42)
  ```
  
  ```r
  digest::digest(r_object, algo = "md5")
  ```
  
  ```
  ## [1] "7238a618715488d3839d9e4b507b3d32"
  ```
  
  ```r
  digest::digest(r_object, algo = "sha256")
  ```
  
  ```
  ## [1] "0c91b468b07e8701fb0c342398b509e9ad3ee7f468b08449592540d6f7ee0b80"
  ```
  ]
  .panel[.panel-name[Digesting text]
  Small changes lead to radically different hashes
  
  ```r
  text &lt;-  "Not Penny's boat"
  text2 &lt;- "Not Penny's boat."
  ```
  
  ```r
  digest::digest(text, algo = "sha256")
  ```
  
  ```
  ## [1] "58b529f7756d833c7f9354b3c824a967cc102b93b85fa9c377fd22beb870e620"
  ```
  
  ```r
  digest::digest(text2, algo = "sha256")
  ```
  
  ```
  ## [1] "d832eb961c2e2696084dbdd6fa17e9c1e74703fe7a0a63c11a272470bcd8e4a8"
  ```
  ]
]


---


name: protecting_passwords

# <i class="fa fa-shield" role="presentation" aria-label="shield icon"></i> Protecting Passwords

.panelset[
  .panel[.panel-name[Saving passwords]
  <i class="fa fa-exclamation-triangle" role="presentation" aria-label="exclamation-triangle icon"></i> You should _never_ save the passwords directly.
  
  ```r
  # Please don't do this
  input$register_password %&gt;% 
    save_password()
  ```
  <i class="fa fa-lock" role="presentation" aria-label="lock icon"></i> Save the generated hash instead.
  
  ```r
  # Much better
  input$register_password %&gt;% 
    digest::digest(algo = "sha256) %&gt;% 
    save_password()
  ```
  ]
  .panel[.panel-name[Verifying credentials]
  Digesting algorithms are deterministic &amp;nbsp; <i class="fa fa-arrow-right" role="presentation" aria-label="arrow-right icon"></i> &amp;nbsp; Equal inputs will always yield the same hash
  
  
  ```r
  verify_credentials &lt;- function(input_username, input_password){
    credentials &lt;- read.csv('credentials.csv') 
    digested_input_password &lt;- digest::digest(input_password, algo = "sha256")
    
    user_credentials &lt;- credentials %&gt;% 
      dplyr::filter(username == input_username) %&gt;% 
      dplyr::filter(hashed_password == digested_input_password)
    
    if(nrow(user_credentials) &gt; 0) return(TRUE) else return(FALSE)
  }
  ```
  
  We can then verify if the password a user introduces is the same they used to register. &lt;br&gt;
  Even if we don't know the actual password!
  ]
  .panel[.panel-name[Salting]
  <i class="fa fa-plus-square" role="presentation" aria-label="plus-square icon"></i> &amp;nbsp; Salt is added to the hashing process to force their uniqueness
  
  ```r
  hash_password &lt;- function(input_password, salt){
    paste0(salt, input_password) %&gt;% digest::digest(algo = "sha256")
  }
  ```
  
  ```r
  hash_password("password1234", salt = "bagel")
  ```
  
  ```
  ## [1] "7cf0997df40c7a5f8aeb3de319712acb93657534e4cd4c70424249ad5934aa71"
  ```
  
  ```r
  hash_password("password1234", salt = "challah")
  ```
  
  ```
  ## [1] "e4472c6495f006b9281a226b1af7ca0eca0f8c51efe7b8e61238fe1e5fb00520"
  ```
  ]
]

---


name: message_authentication

# <i class="fa fa-comments" role="presentation" aria-label="comments icon"></i> Message Authentication

.panelset[
  .panel[.panel-name[MAC]
  <i class="fa fa-user-secret" role="presentation" aria-label="user-secret icon"></i> Like a common password to enter a secret club. A **M**essage **A**uthentication **C**ode (MAC) is based on a shared secret between the sender and the receiver.
  
  
  ```r
  httr::POST(
    url = "http://hydra.island/access",
    body = list(
      message = "Destroy everything",
      secret_code = "polar bear"
    )
  )
  ```
  How do I know it's you who's sending me this? Because you're the only other server who also knows this secret code.
  ]
  .panel[.panel-name[...]
  <i class="fa fa-plane-departure" role="presentation" aria-label="plane-departure icon"></i> Let's say you are a member of the secret service. You are alone on an airport, waiting for your next flight. As you are pretty bored, you open your laptop and look for something to do. You spot a connection called **FREE WIFI AIRPORT**. You log in.
  
  <i class="fa fa-lightbulb" role="presentation" aria-label="lightbulb icon"></i> Now let's say you decide is a great idea to send some important messages to the headquarters. You're very professional, so you'll include the `secret_code` in the message. This way the server knows it's you who sends it. Bulletproof.
  
  <i class="fa fa-door-open" role="presentation" aria-label="door-open icon"></i> The situation is now the following: Whoever runs that WiFi might have intercepted that message. It not only has the power to read _and modify_ the message you just sent. It has the `secret_code` to keep sending messages and pretending to be you in the future. And you might never even notice it.
  ]
  .panel[.panel-name['Salted' MAC]
  <i class="fa fa-plus-square" role="presentation" aria-label="plus-square icon"></i> A safer strategy would be to use our 'Salting' technique to generate the secret code
  
  
  ```r
  message &lt;- "Destroy everything"
  hashed_secret_code &lt;- hash_password(message, salt = "polar bear")
  httr::POST(
    url = "http://hydra.island/access",
    body = list(
      message = message,
      secret_code = hashed_secret_code
    )
  )
  ```
  ]
  .panel[.panel-name[...]
  <i class="fa fa-thumbs-up" role="presentation" aria-label="thumbs-up icon"></i> Now if this is intercepted, only this message will be compromised. Since the `hashed_secret_code` will be different for each message we send. 
  
  <i class="fa fa-shield" role="presentation" aria-label="shield icon"></i> Knowing the message and the `hashed_secret_code` does not get anyone closer to figuring out the `secret_code.
  
  <i class="fa fa-not-equal" role="presentation" aria-label="not-equal icon"></i> If a third party intercepts and modify the message, the server will know. Because the `hashed_secret_code` will not match.
  ]
  .panel[.panel-name[HMAC]
  While salting already accomplishes what we wanted. There are still some vulnerabilities that could be exploited through what is called [length extension attack](https://en.wikipedia.org/wiki/Length_extension_attack). There are well-established functions that concatenate the 'salt' in a more convoluted manner, protecting it from those attacks.
  
  
  ```r
  digest::hmac(object = c(4, 8, 15, 16, 23, 42), key = "polar bear", algo = "sha256")
  ```
  - A HMAC uses a secret key, where as a 'salt' can be public. Though conceptually they're the same.
  - "Salting" simply concatenates a 'salt' before hashing. The HMAC process adds the key in a more complicated way.
  - Adding a `HMAC` is the current standard protocol to authenticate messages.
  ]
]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "googlecode",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:10",
"slideNumberFormat": "<div class=\"progress-bar-container\">\n  <div class=\"progress-bar\" style=\"width: calc(%current% / %total% * 100%);\">\n  </div>\n</div>"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
